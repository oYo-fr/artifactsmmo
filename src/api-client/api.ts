/* tslint:disable */
/* eslint-disable */
/**
 * Artifacts API
 *  Artifacts is an API-based MMO game where you can manage 5 characters to explore, fight, gather resources, craft items and much more.  Website: https://artifactsmmo.com/  Documentation: https://docs.artifactsmmo.com/  OpenAPI Spec: https://api.artifactsmmo.com/openapi.json 
 *
 * The version of the OpenAPI document: 1.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActionItemBankResponseSchema
 */
export interface ActionItemBankResponseSchema {
    /**
     * 
     * @type {BankItemSchema}
     * @memberof ActionItemBankResponseSchema
     */
    'data': BankItemSchema;
}
/**
 * 
 * @export
 * @interface ActiveEventSchema
 */
export interface ActiveEventSchema {
    /**
     * Name of the event.
     * @type {string}
     * @memberof ActiveEventSchema
     */
    'name': string;
    /**
     * Map of the event.
     * @type {MapSchema}
     * @memberof ActiveEventSchema
     */
    'map': MapSchema;
    /**
     * Previous map skin.
     * @type {string}
     * @memberof ActiveEventSchema
     */
    'previous_skin': string;
    /**
     * Duration in minutes.
     * @type {number}
     * @memberof ActiveEventSchema
     */
    'duration': number;
    /**
     * Expiration datetime.
     * @type {string}
     * @memberof ActiveEventSchema
     */
    'expiration': string;
    /**
     * Start datetime.
     * @type {string}
     * @memberof ActiveEventSchema
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface AddAccountSchema
 */
export interface AddAccountSchema {
    /**
     * Your desired username.
     * @type {string}
     * @memberof AddAccountSchema
     */
    'username': string;
    /**
     * Your password.
     * @type {string}
     * @memberof AddAccountSchema
     */
    'password': string;
    /**
     * Your email.
     * @type {string}
     * @memberof AddAccountSchema
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface AddCharacterSchema
 */
export interface AddCharacterSchema {
    /**
     * Your desired character name. It\'s unique and all players can see it.
     * @type {string}
     * @memberof AddCharacterSchema
     */
    'name': string;
    /**
     * Your desired skin.
     * @type {string}
     * @memberof AddCharacterSchema
     */
    'skin': AddCharacterSchemaSkinEnum;
}

export const AddCharacterSchemaSkinEnum = {
    Men1: 'men1',
    Men2: 'men2',
    Men3: 'men3',
    Women1: 'women1',
    Women2: 'women2',
    Women3: 'women3'
} as const;

export type AddCharacterSchemaSkinEnum = typeof AddCharacterSchemaSkinEnum[keyof typeof AddCharacterSchemaSkinEnum];

/**
 * 
 * @export
 * @interface AnnouncementSchema
 */
export interface AnnouncementSchema {
    /**
     * Announcement text.
     * @type {string}
     * @memberof AnnouncementSchema
     */
    'message': string;
    /**
     * Datetime of the announcement.
     * @type {string}
     * @memberof AnnouncementSchema
     */
    'created_at'?: string;
}
/**
 * 
 * @export
 * @interface BankItemSchema
 */
export interface BankItemSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof BankItemSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Item details.
     * @type {ItemSchema}
     * @memberof BankItemSchema
     */
    'item': ItemSchema;
    /**
     * Items in your banks.
     * @type {Array<SimpleItemSchema>}
     * @memberof BankItemSchema
     */
    'bank': Array<SimpleItemSchema>;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof BankItemSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface BlockedHitsSchema
 */
export interface BlockedHitsSchema {
    /**
     * The amount of fire hits blocked.
     * @type {number}
     * @memberof BlockedHitsSchema
     */
    'fire': number;
    /**
     * The amount of earth hits blocked.
     * @type {number}
     * @memberof BlockedHitsSchema
     */
    'earth': number;
    /**
     * The amount of water hits blocked.
     * @type {number}
     * @memberof BlockedHitsSchema
     */
    'water': number;
    /**
     * The amount of air hits blocked.
     * @type {number}
     * @memberof BlockedHitsSchema
     */
    'air': number;
    /**
     * The amount of total hits blocked.
     * @type {number}
     * @memberof BlockedHitsSchema
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface ChangePassword
 */
export interface ChangePassword {
    /**
     * Your password.
     * @type {string}
     * @memberof ChangePassword
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface CharacterFightDataSchema
 */
export interface CharacterFightDataSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof CharacterFightDataSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Fight details.
     * @type {FightSchema}
     * @memberof CharacterFightDataSchema
     */
    'fight': FightSchema;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof CharacterFightDataSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface CharacterFightResponseSchema
 */
export interface CharacterFightResponseSchema {
    /**
     * 
     * @type {CharacterFightDataSchema}
     * @memberof CharacterFightResponseSchema
     */
    'data': CharacterFightDataSchema;
}
/**
 * 
 * @export
 * @interface CharacterMovementDataSchema
 */
export interface CharacterMovementDataSchema {
    /**
     * Cooldown details
     * @type {CooldownSchema}
     * @memberof CharacterMovementDataSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Destination details.
     * @type {MapSchema}
     * @memberof CharacterMovementDataSchema
     */
    'destination': MapSchema;
    /**
     * Character details.
     * @type {CharacterSchema}
     * @memberof CharacterMovementDataSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface CharacterMovementResponseSchema
 */
export interface CharacterMovementResponseSchema {
    /**
     * 
     * @type {CharacterMovementDataSchema}
     * @memberof CharacterMovementResponseSchema
     */
    'data': CharacterMovementDataSchema;
}
/**
 * 
 * @export
 * @interface CharacterResponseSchema
 */
export interface CharacterResponseSchema {
    /**
     * 
     * @type {CharacterSchema}
     * @memberof CharacterResponseSchema
     */
    'data': CharacterSchema;
}
/**
 * 
 * @export
 * @interface CharacterSchema
 */
export interface CharacterSchema {
    /**
     * Name of the character.
     * @type {string}
     * @memberof CharacterSchema
     */
    'name': string;
    /**
     * Character skin code.
     * @type {string}
     * @memberof CharacterSchema
     */
    'skin': CharacterSchemaSkinEnum;
    /**
     * Combat level.
     * @type {number}
     * @memberof CharacterSchema
     */
    'level': number;
    /**
     * The current xp level of the combat level.
     * @type {number}
     * @memberof CharacterSchema
     */
    'xp': number;
    /**
     * XP required to level up the character.
     * @type {number}
     * @memberof CharacterSchema
     */
    'max_xp': number;
    /**
     * Total XP of your character.
     * @type {number}
     * @memberof CharacterSchema
     */
    'total_xp': number;
    /**
     * The numbers of golds on this character.
     * @type {number}
     * @memberof CharacterSchema
     */
    'gold': number;
    /**
     * *Not available, on the roadmap. Character movement speed.
     * @type {number}
     * @memberof CharacterSchema
     */
    'speed': number;
    /**
     * Mining level.
     * @type {number}
     * @memberof CharacterSchema
     */
    'mining_level': number;
    /**
     * The current xp level of the Mining skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'mining_xp': number;
    /**
     * Mining XP required to level up the skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'mining_max_xp': number;
    /**
     * Woodcutting level.
     * @type {number}
     * @memberof CharacterSchema
     */
    'woodcutting_level': number;
    /**
     * The current xp level of the Woodcutting skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'woodcutting_xp': number;
    /**
     * Woodcutting XP required to level up the skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'woodcutting_max_xp': number;
    /**
     * Fishing level.
     * @type {number}
     * @memberof CharacterSchema
     */
    'fishing_level': number;
    /**
     * The current xp level of the Fishing skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'fishing_xp': number;
    /**
     * Fishing XP required to level up the skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'fishing_max_xp': number;
    /**
     * Weaponcrafting level.
     * @type {number}
     * @memberof CharacterSchema
     */
    'weaponcrafting_level': number;
    /**
     * The current xp level of the Weaponcrafting skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'weaponcrafting_xp': number;
    /**
     * Weaponcrafting XP required to level up the skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'weaponcrafting_max_xp': number;
    /**
     * Gearcrafting level.
     * @type {number}
     * @memberof CharacterSchema
     */
    'gearcrafting_level': number;
    /**
     * The current xp level of the Gearcrafting skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'gearcrafting_xp': number;
    /**
     * Gearcrafting XP required to level up the skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'gearcrafting_max_xp': number;
    /**
     * Jewelrycrafting level.
     * @type {number}
     * @memberof CharacterSchema
     */
    'jewelrycrafting_level': number;
    /**
     * The current xp level of the Jewelrycrafting skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'jewelrycrafting_xp': number;
    /**
     * Jewelrycrafting XP required to level up the skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'jewelrycrafting_max_xp': number;
    /**
     * The current xp level of the Cooking skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'cooking_level': number;
    /**
     * Cooking XP.
     * @type {number}
     * @memberof CharacterSchema
     */
    'cooking_xp': number;
    /**
     * Cooking XP required to level up the skill.
     * @type {number}
     * @memberof CharacterSchema
     */
    'cooking_max_xp': number;
    /**
     * Character HP.
     * @type {number}
     * @memberof CharacterSchema
     */
    'hp': number;
    /**
     * *Character Haste. Increase speed attack (reduce fight cooldown)
     * @type {number}
     * @memberof CharacterSchema
     */
    'haste': number;
    /**
     * *Not available, on the roadmap. Character Critical   Strike. Critical strikes increase the attack\'s damage.
     * @type {number}
     * @memberof CharacterSchema
     */
    'critical_strike': number;
    /**
     * *Not available, on the roadmap. Regenerates life at the start of each turn.
     * @type {number}
     * @memberof CharacterSchema
     */
    'stamina': number;
    /**
     * Fire attack.
     * @type {number}
     * @memberof CharacterSchema
     */
    'attack_fire': number;
    /**
     * Earth attack.
     * @type {number}
     * @memberof CharacterSchema
     */
    'attack_earth': number;
    /**
     * Water attack.
     * @type {number}
     * @memberof CharacterSchema
     */
    'attack_water': number;
    /**
     * Air attack.
     * @type {number}
     * @memberof CharacterSchema
     */
    'attack_air': number;
    /**
     * % Fire damage.
     * @type {number}
     * @memberof CharacterSchema
     */
    'dmg_fire': number;
    /**
     * % Earth damage.
     * @type {number}
     * @memberof CharacterSchema
     */
    'dmg_earth': number;
    /**
     * % Water damage.
     * @type {number}
     * @memberof CharacterSchema
     */
    'dmg_water': number;
    /**
     * % Air damage.
     * @type {number}
     * @memberof CharacterSchema
     */
    'dmg_air': number;
    /**
     * % Fire resistance.
     * @type {number}
     * @memberof CharacterSchema
     */
    'res_fire': number;
    /**
     * % Earth resistance.
     * @type {number}
     * @memberof CharacterSchema
     */
    'res_earth': number;
    /**
     * % Water resistance.
     * @type {number}
     * @memberof CharacterSchema
     */
    'res_water': number;
    /**
     * % Air resistance.
     * @type {number}
     * @memberof CharacterSchema
     */
    'res_air': number;
    /**
     * Character x coordinate.
     * @type {number}
     * @memberof CharacterSchema
     */
    'x': number;
    /**
     * Character y coordinate.
     * @type {number}
     * @memberof CharacterSchema
     */
    'y': number;
    /**
     * Cooldown in seconds.
     * @type {number}
     * @memberof CharacterSchema
     */
    'cooldown': number;
    /**
     * Datetime Cooldown expiration.
     * @type {string}
     * @memberof CharacterSchema
     */
    'cooldown_expiration'?: string;
    /**
     * Weapon slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'weapon_slot': string;
    /**
     * Shield slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'shield_slot': string;
    /**
     * Helmet slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'helmet_slot': string;
    /**
     * Body armor slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'body_armor_slot': string;
    /**
     * Leg armor slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'leg_armor_slot': string;
    /**
     * Boots slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'boots_slot': string;
    /**
     * Ring 1 slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'ring1_slot': string;
    /**
     * Ring 2 slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'ring2_slot': string;
    /**
     * Amulet slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'amulet_slot': string;
    /**
     * Artifact 1 slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'artifact1_slot': string;
    /**
     * Artifact 2 slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'artifact2_slot': string;
    /**
     * Artifact 3 slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'artifact3_slot': string;
    /**
     * Consumable 1 slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'consumable1_slot': string;
    /**
     * Consumable 1 quantity.
     * @type {number}
     * @memberof CharacterSchema
     */
    'consumable1_slot_quantity': number;
    /**
     * Consumable 2 slot.
     * @type {string}
     * @memberof CharacterSchema
     */
    'consumable2_slot': string;
    /**
     * Consumable 2 quantity.
     * @type {number}
     * @memberof CharacterSchema
     */
    'consumable2_slot_quantity': number;
    /**
     * Task in progress.
     * @type {string}
     * @memberof CharacterSchema
     */
    'task': string;
    /**
     * Task type.
     * @type {string}
     * @memberof CharacterSchema
     */
    'task_type': string;
    /**
     * Task progression.
     * @type {number}
     * @memberof CharacterSchema
     */
    'task_progress': number;
    /**
     * Task total objective.
     * @type {number}
     * @memberof CharacterSchema
     */
    'task_total': number;
    /**
     * Inventory max items.
     * @type {number}
     * @memberof CharacterSchema
     */
    'inventory_max_items': number;
    /**
     * List of inventory slots.
     * @type {Array<InventorySlot>}
     * @memberof CharacterSchema
     */
    'inventory'?: Array<InventorySlot>;
}

export const CharacterSchemaSkinEnum = {
    Men1: 'men1',
    Men2: 'men2',
    Men3: 'men3',
    Women1: 'women1',
    Women2: 'women2',
    Women3: 'women3'
} as const;

export type CharacterSchemaSkinEnum = typeof CharacterSchemaSkinEnum[keyof typeof CharacterSchemaSkinEnum];

/**
 * 
 * @export
 * @interface CooldownSchema
 */
export interface CooldownSchema {
    /**
     * The total seconds of the cooldown.
     * @type {number}
     * @memberof CooldownSchema
     */
    'total_seconds': number;
    /**
     * The remaining seconds of the cooldown.
     * @type {number}
     * @memberof CooldownSchema
     */
    'remaining_seconds': number;
    /**
     * The start of the cooldown.
     * @type {string}
     * @memberof CooldownSchema
     */
    'started_at': string;
    /**
     * The expiration of the cooldown.
     * @type {string}
     * @memberof CooldownSchema
     */
    'expiration': string;
    /**
     * The reason of the cooldown.
     * @type {string}
     * @memberof CooldownSchema
     */
    'reason': CooldownSchemaReasonEnum;
}

export const CooldownSchemaReasonEnum = {
    Movement: 'movement',
    Fight: 'fight',
    Crafting: 'crafting',
    Gathering: 'gathering',
    BuyGe: 'buy_ge',
    SellGe: 'sell_ge',
    DeleteItem: 'delete_item',
    DepositBank: 'deposit_bank',
    WithdrawBank: 'withdraw_bank',
    Equip: 'equip',
    Unequip: 'unequip',
    Task: 'task',
    Recycling: 'recycling'
} as const;

export type CooldownSchemaReasonEnum = typeof CooldownSchemaReasonEnum[keyof typeof CooldownSchemaReasonEnum];

/**
 * 
 * @export
 * @interface CraftSchema
 */
export interface CraftSchema {
    /**
     * Skill required to craft the item.
     * @type {string}
     * @memberof CraftSchema
     */
    'skill'?: CraftSchemaSkillEnum;
    /**
     * The skill level required to craft the item.
     * @type {number}
     * @memberof CraftSchema
     */
    'level'?: number;
    /**
     * List of items required to craft the item.
     * @type {Array<SimpleItemSchema>}
     * @memberof CraftSchema
     */
    'items'?: Array<SimpleItemSchema>;
    /**
     * Quantity of items crafted.
     * @type {number}
     * @memberof CraftSchema
     */
    'quantity'?: number;
}

export const CraftSchemaSkillEnum = {
    Weaponcrafting: 'weaponcrafting',
    Gearcrafting: 'gearcrafting',
    Jewelrycrafting: 'jewelrycrafting',
    Cooking: 'cooking',
    Woodcutting: 'woodcutting',
    Mining: 'mining'
} as const;

export type CraftSchemaSkillEnum = typeof CraftSchemaSkillEnum[keyof typeof CraftSchemaSkillEnum];

/**
 * 
 * @export
 * @interface CraftingSchema
 */
export interface CraftingSchema {
    /**
     * Craft code.
     * @type {string}
     * @memberof CraftingSchema
     */
    'code': string;
    /**
     * Quantity of items to craft.
     * @type {number}
     * @memberof CraftingSchema
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface DataPageActiveEventSchema
 */
export interface DataPageActiveEventSchema {
    /**
     * 
     * @type {Array<ActiveEventSchema>}
     * @memberof DataPageActiveEventSchema
     */
    'data': Array<ActiveEventSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageActiveEventSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageActiveEventSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageActiveEventSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageActiveEventSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DataPageCharacterSchema
 */
export interface DataPageCharacterSchema {
    /**
     * 
     * @type {Array<CharacterSchema>}
     * @memberof DataPageCharacterSchema
     */
    'data': Array<CharacterSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageCharacterSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageCharacterSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageCharacterSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageCharacterSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DataPageGEItemSchema
 */
export interface DataPageGEItemSchema {
    /**
     * 
     * @type {Array<GEItemSchema>}
     * @memberof DataPageGEItemSchema
     */
    'data': Array<GEItemSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageGEItemSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageGEItemSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageGEItemSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageGEItemSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DataPageItemSchema
 */
export interface DataPageItemSchema {
    /**
     * 
     * @type {Array<ItemSchema>}
     * @memberof DataPageItemSchema
     */
    'data': Array<ItemSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageItemSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageItemSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageItemSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageItemSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DataPageLogSchema
 */
export interface DataPageLogSchema {
    /**
     * 
     * @type {Array<LogSchema>}
     * @memberof DataPageLogSchema
     */
    'data': Array<LogSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageLogSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageLogSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageLogSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageLogSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DataPageMapSchema
 */
export interface DataPageMapSchema {
    /**
     * 
     * @type {Array<MapSchema>}
     * @memberof DataPageMapSchema
     */
    'data': Array<MapSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageMapSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageMapSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageMapSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageMapSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DataPageMonsterSchema
 */
export interface DataPageMonsterSchema {
    /**
     * 
     * @type {Array<MonsterSchema>}
     * @memberof DataPageMonsterSchema
     */
    'data': Array<MonsterSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageMonsterSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageMonsterSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageMonsterSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageMonsterSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DataPageResourceSchema
 */
export interface DataPageResourceSchema {
    /**
     * 
     * @type {Array<ResourceSchema>}
     * @memberof DataPageResourceSchema
     */
    'data': Array<ResourceSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageResourceSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageResourceSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageResourceSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageResourceSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DataPageSimpleItemSchema
 */
export interface DataPageSimpleItemSchema {
    /**
     * 
     * @type {Array<SimpleItemSchema>}
     * @memberof DataPageSimpleItemSchema
     */
    'data': Array<SimpleItemSchema>;
    /**
     * 
     * @type {number}
     * @memberof DataPageSimpleItemSchema
     */
    'total': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageSimpleItemSchema
     */
    'page': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageSimpleItemSchema
     */
    'size': number | null;
    /**
     * 
     * @type {number}
     * @memberof DataPageSimpleItemSchema
     */
    'pages'?: number | null;
}
/**
 * 
 * @export
 * @interface DeleteCharacterSchema
 */
export interface DeleteCharacterSchema {
    /**
     * Character name.
     * @type {string}
     * @memberof DeleteCharacterSchema
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface DeleteItemResponseSchema
 */
export interface DeleteItemResponseSchema {
    /**
     * 
     * @type {DeleteItemSchema}
     * @memberof DeleteItemResponseSchema
     */
    'data': DeleteItemSchema;
}
/**
 * 
 * @export
 * @interface DeleteItemSchema
 */
export interface DeleteItemSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof DeleteItemSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Item details.
     * @type {SimpleItemSchema}
     * @memberof DeleteItemSchema
     */
    'item': SimpleItemSchema;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof DeleteItemSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface DepositWithdrawGoldSchema
 */
export interface DepositWithdrawGoldSchema {
    /**
     * Quantity of gold.
     * @type {number}
     * @memberof DepositWithdrawGoldSchema
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface DestinationSchema
 */
export interface DestinationSchema {
    /**
     * The x coordinate of the destination.
     * @type {number}
     * @memberof DestinationSchema
     */
    'x': number;
    /**
     * The y coordinate of the destination.
     * @type {number}
     * @memberof DestinationSchema
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface DropRateSchema
 */
export interface DropRateSchema {
    /**
     * Item code.
     * @type {string}
     * @memberof DropRateSchema
     */
    'code': string;
    /**
     * Chance rate.
     * @type {number}
     * @memberof DropRateSchema
     */
    'rate': number;
    /**
     * Minimum quantity.
     * @type {number}
     * @memberof DropRateSchema
     */
    'min_quantity': number;
    /**
     * Maximum quantity.
     * @type {number}
     * @memberof DropRateSchema
     */
    'max_quantity': number;
}
/**
 * 
 * @export
 * @interface DropSchema
 */
export interface DropSchema {
    /**
     * The code of the item.
     * @type {string}
     * @memberof DropSchema
     */
    'code': string;
    /**
     * The quantity of the item.
     * @type {number}
     * @memberof DropSchema
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface EquipRequestSchema
 */
export interface EquipRequestSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof EquipRequestSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Item slot.
     * @type {string}
     * @memberof EquipRequestSchema
     */
    'slot': EquipRequestSchemaSlotEnum;
    /**
     * Item details.
     * @type {ItemSchema}
     * @memberof EquipRequestSchema
     */
    'item': ItemSchema;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof EquipRequestSchema
     */
    'character': CharacterSchema;
}

export const EquipRequestSchemaSlotEnum = {
    Weapon: 'weapon',
    Shield: 'shield',
    Helmet: 'helmet',
    BodyArmor: 'body_armor',
    LegArmor: 'leg_armor',
    Boots: 'boots',
    Ring1: 'ring1',
    Ring2: 'ring2',
    Amulet: 'amulet',
    Artifact1: 'artifact1',
    Artifact2: 'artifact2',
    Artifact3: 'artifact3',
    Consumable1: 'consumable1',
    Consumable2: 'consumable2'
} as const;

export type EquipRequestSchemaSlotEnum = typeof EquipRequestSchemaSlotEnum[keyof typeof EquipRequestSchemaSlotEnum];

/**
 * 
 * @export
 * @interface EquipSchema
 */
export interface EquipSchema {
    /**
     * Item code.
     * @type {string}
     * @memberof EquipSchema
     */
    'code': string;
    /**
     * Item slot.
     * @type {string}
     * @memberof EquipSchema
     */
    'slot': EquipSchemaSlotEnum;
}

export const EquipSchemaSlotEnum = {
    Weapon: 'weapon',
    Shield: 'shield',
    Helmet: 'helmet',
    BodyArmor: 'body_armor',
    LegArmor: 'leg_armor',
    Boots: 'boots',
    Ring1: 'ring1',
    Ring2: 'ring2',
    Amulet: 'amulet',
    Artifact1: 'artifact1',
    Artifact2: 'artifact2',
    Artifact3: 'artifact3',
    Consumable1: 'consumable1',
    Consumable2: 'consumable2'
} as const;

export type EquipSchemaSlotEnum = typeof EquipSchemaSlotEnum[keyof typeof EquipSchemaSlotEnum];

/**
 * 
 * @export
 * @interface EquipmentResponseSchema
 */
export interface EquipmentResponseSchema {
    /**
     * 
     * @type {EquipRequestSchema}
     * @memberof EquipmentResponseSchema
     */
    'data': EquipRequestSchema;
}
/**
 * 
 * @export
 * @interface FightSchema
 */
export interface FightSchema {
    /**
     * The amount of xp gained by the fight.
     * @type {number}
     * @memberof FightSchema
     */
    'xp': number;
    /**
     * The amount of gold gained by the fight.
     * @type {number}
     * @memberof FightSchema
     */
    'gold': number;
    /**
     * The items dropped by the fight.
     * @type {Array<DropSchema>}
     * @memberof FightSchema
     */
    'drops': Array<DropSchema>;
    /**
     * Numbers of the turns of the combat.
     * @type {number}
     * @memberof FightSchema
     */
    'turns': number;
    /**
     * The amount of blocked hits by the monster.
     * @type {BlockedHitsSchema}
     * @memberof FightSchema
     */
    'monster_blocked_hits': BlockedHitsSchema;
    /**
     * The amount of blocked hits by the player.
     * @type {BlockedHitsSchema}
     * @memberof FightSchema
     */
    'player_blocked_hits': BlockedHitsSchema;
    /**
     * The fight logs.
     * @type {Array<string>}
     * @memberof FightSchema
     */
    'logs': Array<string>;
    /**
     * The result of the fight.
     * @type {string}
     * @memberof FightSchema
     */
    'result': FightSchemaResultEnum;
}

export const FightSchemaResultEnum = {
    Win: 'win',
    Lose: 'lose'
} as const;

export type FightSchemaResultEnum = typeof FightSchemaResultEnum[keyof typeof FightSchemaResultEnum];

/**
 * 
 * @export
 * @interface GEItemResponseSchema
 */
export interface GEItemResponseSchema {
    /**
     * 
     * @type {GEItemSchema}
     * @memberof GEItemResponseSchema
     */
    'data': GEItemSchema;
}
/**
 * 
 * @export
 * @interface GEItemSchema
 */
export interface GEItemSchema {
    /**
     * Item code.
     * @type {string}
     * @memberof GEItemSchema
     */
    'code': string;
    /**
     * Item stock.
     * @type {number}
     * @memberof GEItemSchema
     */
    'stock': number;
    /**
     * The item\'s selling price.
     * @type {number}
     * @memberof GEItemSchema
     */
    'sell_price'?: number;
    /**
     * The item\'s buying price.
     * @type {number}
     * @memberof GEItemSchema
     */
    'buy_price'?: number;
}
/**
 * 
 * @export
 * @interface GETransactionItemSchema
 */
export interface GETransactionItemSchema {
    /**
     * Item code.
     * @type {string}
     * @memberof GETransactionItemSchema
     */
    'code': string;
    /**
     * Item quantity.
     * @type {number}
     * @memberof GETransactionItemSchema
     */
    'quantity': number;
    /**
     * Item price. Item price validation protects you if the price has changed since you last checked the buy/sale price of an item.
     * @type {number}
     * @memberof GETransactionItemSchema
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface GETransactionListSchema
 */
export interface GETransactionListSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof GETransactionListSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Transaction details.
     * @type {GETransactionSchema}
     * @memberof GETransactionListSchema
     */
    'transaction': GETransactionSchema;
    /**
     * Character details.
     * @type {CharacterSchema}
     * @memberof GETransactionListSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface GETransactionResponseSchema
 */
export interface GETransactionResponseSchema {
    /**
     * 
     * @type {GETransactionListSchema}
     * @memberof GETransactionResponseSchema
     */
    'data': GETransactionListSchema;
}
/**
 * 
 * @export
 * @interface GETransactionSchema
 */
export interface GETransactionSchema {
    /**
     * Item code.
     * @type {string}
     * @memberof GETransactionSchema
     */
    'code': string;
    /**
     * Item quantity.
     * @type {number}
     * @memberof GETransactionSchema
     */
    'quantity': number;
    /**
     * Item price.
     * @type {number}
     * @memberof GETransactionSchema
     */
    'price': number;
    /**
     * Total price of the transaction.
     * @type {number}
     * @memberof GETransactionSchema
     */
    'total_price': number;
}
/**
 * 
 * @export
 * @interface GoldBankResponseSchema
 */
export interface GoldBankResponseSchema {
    /**
     * 
     * @type {GoldSchema}
     * @memberof GoldBankResponseSchema
     */
    'data': GoldSchema;
}
/**
 * 
 * @export
 * @interface GoldResponseSchema
 */
export interface GoldResponseSchema {
    /**
     * 
     * @type {GoldTransactionSchema}
     * @memberof GoldResponseSchema
     */
    'data': GoldTransactionSchema;
}
/**
 * 
 * @export
 * @interface GoldSchema
 */
export interface GoldSchema {
    /**
     * Quantity of gold.
     * @type {number}
     * @memberof GoldSchema
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface GoldTransactionSchema
 */
export interface GoldTransactionSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof GoldTransactionSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Bank details.
     * @type {GoldSchema}
     * @memberof GoldTransactionSchema
     */
    'bank': GoldSchema;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof GoldTransactionSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface InventorySlot
 */
export interface InventorySlot {
    /**
     * Inventory slot identifier.
     * @type {number}
     * @memberof InventorySlot
     */
    'slot': number;
    /**
     * Item code.
     * @type {string}
     * @memberof InventorySlot
     */
    'code': string;
    /**
     * Quantity in the slot.
     * @type {number}
     * @memberof InventorySlot
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface ItemEffectSchema
 */
export interface ItemEffectSchema {
    /**
     * Effect name.
     * @type {string}
     * @memberof ItemEffectSchema
     */
    'name': string;
    /**
     * Effect value.
     * @type {number}
     * @memberof ItemEffectSchema
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface ItemResponseSchema
 */
export interface ItemResponseSchema {
    /**
     * 
     * @type {SingleItemSchema}
     * @memberof ItemResponseSchema
     */
    'data': SingleItemSchema;
}
/**
 * 
 * @export
 * @interface ItemSchema
 */
export interface ItemSchema {
    /**
     * Item name.
     * @type {string}
     * @memberof ItemSchema
     */
    'name': string;
    /**
     * Item code. This is the item\'s unique identifier (ID).
     * @type {string}
     * @memberof ItemSchema
     */
    'code': string;
    /**
     * Item level.
     * @type {number}
     * @memberof ItemSchema
     */
    'level': number;
    /**
     * Item type.
     * @type {string}
     * @memberof ItemSchema
     */
    'type': string;
    /**
     * Item subtype.
     * @type {string}
     * @memberof ItemSchema
     */
    'subtype': string;
    /**
     * Item description.
     * @type {string}
     * @memberof ItemSchema
     */
    'description': string;
    /**
     * List of object effects. For equipment, it will include item stats.
     * @type {Array<ItemEffectSchema>}
     * @memberof ItemSchema
     */
    'effects'?: Array<ItemEffectSchema>;
    /**
     * 
     * @type {CraftSchema}
     * @memberof ItemSchema
     */
    'craft'?: CraftSchema | null;
}
/**
 * 
 * @export
 * @interface LogSchema
 */
export interface LogSchema {
    /**
     * Character name.
     * @type {string}
     * @memberof LogSchema
     */
    'character': string;
    /**
     * Account character.
     * @type {string}
     * @memberof LogSchema
     */
    'account': string;
    /**
     * Type of action.
     * @type {string}
     * @memberof LogSchema
     */
    'type': string;
    /**
     * Description of action.
     * @type {string}
     * @memberof LogSchema
     */
    'description': string;
    /**
     * 
     * @type {any}
     * @memberof LogSchema
     */
    'content': any;
    /**
     * Cooldown in seconds.
     * @type {number}
     * @memberof LogSchema
     */
    'cooldown': number;
    /**
     * Datetime of cooldown expiration.
     * @type {string}
     * @memberof LogSchema
     */
    'cooldown_expiration': string;
    /**
     * Datetime of creation.
     * @type {string}
     * @memberof LogSchema
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface MapContentSchema
 */
export interface MapContentSchema {
    /**
     * Type of the content.
     * @type {string}
     * @memberof MapContentSchema
     */
    'type': string;
    /**
     * Code of the content.
     * @type {string}
     * @memberof MapContentSchema
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface MapResponseSchema
 */
export interface MapResponseSchema {
    /**
     * 
     * @type {MapSchema}
     * @memberof MapResponseSchema
     */
    'data': MapSchema;
}
/**
 * 
 * @export
 * @interface MapSchema
 */
export interface MapSchema {
    /**
     * Name of the map.
     * @type {string}
     * @memberof MapSchema
     */
    'name': string;
    /**
     * Skin of the map.
     * @type {string}
     * @memberof MapSchema
     */
    'skin': string;
    /**
     * Position X of the map.
     * @type {number}
     * @memberof MapSchema
     */
    'x': number;
    /**
     * Position Y of the map.
     * @type {number}
     * @memberof MapSchema
     */
    'y': number;
    /**
     * 
     * @type {MapContentSchema}
     * @memberof MapSchema
     */
    'content': MapContentSchema | null;
}
/**
 * 
 * @export
 * @interface MonsterResponseSchema
 */
export interface MonsterResponseSchema {
    /**
     * 
     * @type {MonsterSchema}
     * @memberof MonsterResponseSchema
     */
    'data': MonsterSchema;
}
/**
 * 
 * @export
 * @interface MonsterSchema
 */
export interface MonsterSchema {
    /**
     * Name of the monster.
     * @type {string}
     * @memberof MonsterSchema
     */
    'name': string;
    /**
     * The code of the monster. This is the monster\'s unique identifier (ID).
     * @type {string}
     * @memberof MonsterSchema
     */
    'code': string;
    /**
     * Monster level.
     * @type {number}
     * @memberof MonsterSchema
     */
    'level': number;
    /**
     * Monster hit points.
     * @type {number}
     * @memberof MonsterSchema
     */
    'hp': number;
    /**
     * Monster fire attack.
     * @type {number}
     * @memberof MonsterSchema
     */
    'attack_fire': number;
    /**
     * Monster earth attack.
     * @type {number}
     * @memberof MonsterSchema
     */
    'attack_earth': number;
    /**
     * Monster water attack.
     * @type {number}
     * @memberof MonsterSchema
     */
    'attack_water': number;
    /**
     * Monster air attack.
     * @type {number}
     * @memberof MonsterSchema
     */
    'attack_air': number;
    /**
     * Monster % fire resistance.
     * @type {number}
     * @memberof MonsterSchema
     */
    'res_fire': number;
    /**
     * Monster % earth resistance.
     * @type {number}
     * @memberof MonsterSchema
     */
    'res_earth': number;
    /**
     * Monster % water resistance.
     * @type {number}
     * @memberof MonsterSchema
     */
    'res_water': number;
    /**
     * Monster % air resistance.
     * @type {number}
     * @memberof MonsterSchema
     */
    'res_air': number;
    /**
     * Monster minimum gold drop. 
     * @type {number}
     * @memberof MonsterSchema
     */
    'min_gold': number;
    /**
     * Monster maximum gold drop. 
     * @type {number}
     * @memberof MonsterSchema
     */
    'max_gold': number;
    /**
     * Monster drops. This is a list of items that the monster drops after killing the monster. 
     * @type {Array<DropRateSchema>}
     * @memberof MonsterSchema
     */
    'drops': Array<DropRateSchema>;
}
/**
 * 
 * @export
 * @interface MyCharactersListSchema
 */
export interface MyCharactersListSchema {
    /**
     * List of your characters.
     * @type {Array<CharacterSchema>}
     * @memberof MyCharactersListSchema
     */
    'data': Array<CharacterSchema>;
}
/**
 * 
 * @export
 * @interface RecyclingDataSchema
 */
export interface RecyclingDataSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof RecyclingDataSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Craft details.
     * @type {RecyclingItemsSchema}
     * @memberof RecyclingDataSchema
     */
    'details': RecyclingItemsSchema;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof RecyclingDataSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface RecyclingItemsSchema
 */
export interface RecyclingItemsSchema {
    /**
     * Objects received.
     * @type {Array<DropSchema>}
     * @memberof RecyclingItemsSchema
     */
    'items': Array<DropSchema>;
}
/**
 * 
 * @export
 * @interface RecyclingResponseSchema
 */
export interface RecyclingResponseSchema {
    /**
     * 
     * @type {RecyclingDataSchema}
     * @memberof RecyclingResponseSchema
     */
    'data': RecyclingDataSchema;
}
/**
 * 
 * @export
 * @interface RecyclingSchema
 */
export interface RecyclingSchema {
    /**
     * Item code.
     * @type {string}
     * @memberof RecyclingSchema
     */
    'code': string;
    /**
     * Quantity of items to recycle.
     * @type {number}
     * @memberof RecyclingSchema
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface ResourceResponseSchema
 */
export interface ResourceResponseSchema {
    /**
     * 
     * @type {ResourceSchema}
     * @memberof ResourceResponseSchema
     */
    'data': ResourceSchema;
}
/**
 * 
 * @export
 * @interface ResourceSchema
 */
export interface ResourceSchema {
    /**
     * The name of the resource
     * @type {string}
     * @memberof ResourceSchema
     */
    'name': string;
    /**
     * The code of the resource. This is the resource\'s unique identifier (ID).
     * @type {string}
     * @memberof ResourceSchema
     */
    'code': string;
    /**
     * The skill required to gather this resource.
     * @type {string}
     * @memberof ResourceSchema
     */
    'skill': ResourceSchemaSkillEnum;
    /**
     * The skill level required to gather this resource.
     * @type {number}
     * @memberof ResourceSchema
     */
    'level': number;
    /**
     * The drops of this resource.
     * @type {Array<DropRateSchema>}
     * @memberof ResourceSchema
     */
    'drops': Array<DropRateSchema>;
}

export const ResourceSchemaSkillEnum = {
    Mining: 'mining',
    Woodcutting: 'woodcutting',
    Fishing: 'fishing'
} as const;

export type ResourceSchemaSkillEnum = typeof ResourceSchemaSkillEnum[keyof typeof ResourceSchemaSkillEnum];

/**
 * 
 * @export
 * @interface ResponseSchema
 */
export interface ResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof ResponseSchema
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface SimpleItemSchema
 */
export interface SimpleItemSchema {
    /**
     * Item code.
     * @type {string}
     * @memberof SimpleItemSchema
     */
    'code': string;
    /**
     * Item quantity.
     * @type {number}
     * @memberof SimpleItemSchema
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface SingleItemSchema
 */
export interface SingleItemSchema {
    /**
     * Item information.
     * @type {ItemSchema}
     * @memberof SingleItemSchema
     */
    'item': ItemSchema;
    /**
     * 
     * @type {GEItemSchema}
     * @memberof SingleItemSchema
     */
    'ge'?: GEItemSchema | null;
}
/**
 * 
 * @export
 * @interface SkillDataSchema
 */
export interface SkillDataSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof SkillDataSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Craft details.
     * @type {SkillInfoSchema}
     * @memberof SkillDataSchema
     */
    'details': SkillInfoSchema;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof SkillDataSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface SkillInfoSchema
 */
export interface SkillInfoSchema {
    /**
     * The amount of xp gained.
     * @type {number}
     * @memberof SkillInfoSchema
     */
    'xp': number;
    /**
     * Objects received.
     * @type {Array<DropSchema>}
     * @memberof SkillInfoSchema
     */
    'items': Array<DropSchema>;
}
/**
 * 
 * @export
 * @interface SkillResponseSchema
 */
export interface SkillResponseSchema {
    /**
     * 
     * @type {SkillDataSchema}
     * @memberof SkillResponseSchema
     */
    'data': SkillDataSchema;
}
/**
 * 
 * @export
 * @interface StatusResponseSchema
 */
export interface StatusResponseSchema {
    /**
     * 
     * @type {StatusSchema}
     * @memberof StatusResponseSchema
     */
    'data': StatusSchema;
}
/**
 * 
 * @export
 * @interface StatusSchema
 */
export interface StatusSchema {
    /**
     * Server status
     * @type {string}
     * @memberof StatusSchema
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof StatusSchema
     */
    'version'?: string;
    /**
     * 
     * @type {number}
     * @memberof StatusSchema
     */
    'characters_online'?: number;
    /**
     * 
     * @type {string}
     * @memberof StatusSchema
     */
    'server_time'?: string;
    /**
     * 
     * @type {Array<AnnouncementSchema>}
     * @memberof StatusSchema
     */
    'announcements'?: Array<AnnouncementSchema>;
    /**
     * Last server wipe.
     * @type {string}
     * @memberof StatusSchema
     */
    'last_wipe': string;
    /**
     * Next server wipe.
     * @type {string}
     * @memberof StatusSchema
     */
    'next_wipe': string;
}
/**
 * 
 * @export
 * @interface TaskDataSchema
 */
export interface TaskDataSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof TaskDataSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Task details.
     * @type {TaskSchema}
     * @memberof TaskDataSchema
     */
    'task': TaskSchema;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof TaskDataSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface TaskResponseSchema
 */
export interface TaskResponseSchema {
    /**
     * 
     * @type {TaskDataSchema}
     * @memberof TaskResponseSchema
     */
    'data': TaskDataSchema;
}
/**
 * 
 * @export
 * @interface TaskRewardDataSchema
 */
export interface TaskRewardDataSchema {
    /**
     * Cooldown details.
     * @type {CooldownSchema}
     * @memberof TaskRewardDataSchema
     */
    'cooldown': CooldownSchema;
    /**
     * Reward details.
     * @type {TaskRewardSchema}
     * @memberof TaskRewardDataSchema
     */
    'reward': TaskRewardSchema;
    /**
     * Player details.
     * @type {CharacterSchema}
     * @memberof TaskRewardDataSchema
     */
    'character': CharacterSchema;
}
/**
 * 
 * @export
 * @interface TaskRewardResponseSchema
 */
export interface TaskRewardResponseSchema {
    /**
     * 
     * @type {TaskRewardDataSchema}
     * @memberof TaskRewardResponseSchema
     */
    'data': TaskRewardDataSchema;
}
/**
 * 
 * @export
 * @interface TaskRewardSchema
 */
export interface TaskRewardSchema {
    /**
     * Item code.
     * @type {string}
     * @memberof TaskRewardSchema
     */
    'code': string;
    /**
     * Item quantity.
     * @type {number}
     * @memberof TaskRewardSchema
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface TaskSchema
 */
export interface TaskSchema {
    /**
     * Task objective.
     * @type {string}
     * @memberof TaskSchema
     */
    'code': string;
    /**
     * The type of task.
     * @type {string}
     * @memberof TaskSchema
     */
    'type': TaskSchemaTypeEnum;
    /**
     * The total required to complete the task.
     * @type {number}
     * @memberof TaskSchema
     */
    'total': number;
}

export const TaskSchemaTypeEnum = {
    Monsters: 'monsters',
    Resources: 'resources',
    Crafts: 'crafts'
} as const;

export type TaskSchemaTypeEnum = typeof TaskSchemaTypeEnum[keyof typeof TaskSchemaTypeEnum];

/**
 * 
 * @export
 * @interface TokenResponseSchema
 */
export interface TokenResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof TokenResponseSchema
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UnequipSchema
 */
export interface UnequipSchema {
    /**
     * Item slot.
     * @type {string}
     * @memberof UnequipSchema
     */
    'slot': UnequipSchemaSlotEnum;
}

export const UnequipSchemaSlotEnum = {
    Weapon: 'weapon',
    Shield: 'shield',
    Helmet: 'helmet',
    BodyArmor: 'body_armor',
    LegArmor: 'leg_armor',
    Boots: 'boots',
    Ring1: 'ring1',
    Ring2: 'ring2',
    Amulet: 'amulet',
    Artifact1: 'artifact1',
    Artifact2: 'artifact2',
    Artifact3: 'artifact3',
    Consumable1: 'consumable1',
    Consumable2: 'consumable2'
} as const;

export type UnequipSchemaSlotEnum = typeof UnequipSchemaSlotEnum[keyof typeof UnequipSchemaSlotEnum];

/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an account.
         * @summary Create Account
         * @param {AddAccountSchema} addAccountSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountAccountsCreatePost: async (addAccountSchema: AddAccountSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addAccountSchema' is not null or undefined
            assertParamExists('createAccountAccountsCreatePost', 'addAccountSchema', addAccountSchema)
            const localVarPath = `/accounts/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addAccountSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an account.
         * @summary Create Account
         * @param {AddAccountSchema} addAccountSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountAccountsCreatePost(addAccountSchema: AddAccountSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountAccountsCreatePost(addAccountSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.createAccountAccountsCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Create an account.
         * @summary Create Account
         * @param {AddAccountSchema} addAccountSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountAccountsCreatePost(addAccountSchema: AddAccountSchema, options?: any): AxiosPromise<ResponseSchema> {
            return localVarFp.createAccountAccountsCreatePost(addAccountSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Create an account.
     * @summary Create Account
     * @param {AddAccountSchema} addAccountSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createAccountAccountsCreatePost(addAccountSchema: AddAccountSchema, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createAccountAccountsCreatePost(addAccountSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CharactersApi - axios parameter creator
 * @export
 */
export const CharactersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new character on your account. You can create up to 5 characters.
         * @summary Create Character
         * @param {AddCharacterSchema} addCharacterSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterCharactersCreatePost: async (addCharacterSchema: AddCharacterSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addCharacterSchema' is not null or undefined
            assertParamExists('createCharacterCharactersCreatePost', 'addCharacterSchema', addCharacterSchema)
            const localVarPath = `/characters/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCharacterSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete character on your account.
         * @summary Delete Character
         * @param {DeleteCharacterSchema} deleteCharacterSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterCharactersDeletePost: async (deleteCharacterSchema: DeleteCharacterSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteCharacterSchema' is not null or undefined
            assertParamExists('deleteCharacterCharactersDeletePost', 'deleteCharacterSchema', deleteCharacterSchema)
            const localVarPath = `/characters/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteCharacterSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch characters details.
         * @summary Get All Characters
         * @param {GetAllCharactersCharactersGetSortEnum} [sort] Default sort by combat total XP.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCharactersCharactersGet: async (sort?: GetAllCharactersCharactersGetSortEnum, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/characters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a character.
         * @summary Get Character
         * @param {string} name The character name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterCharactersNameGet: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getCharacterCharactersNameGet', 'name', name)
            const localVarPath = `/characters/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CharactersApi - functional programming interface
 * @export
 */
export const CharactersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CharactersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new character on your account. You can create up to 5 characters.
         * @summary Create Character
         * @param {AddCharacterSchema} addCharacterSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCharacterCharactersCreatePost(addCharacterSchema: AddCharacterSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCharacterCharactersCreatePost(addCharacterSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharactersApi.createCharacterCharactersCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete character on your account.
         * @summary Delete Character
         * @param {DeleteCharacterSchema} deleteCharacterSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCharacterCharactersDeletePost(deleteCharacterSchema: DeleteCharacterSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCharacterCharactersDeletePost(deleteCharacterSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharactersApi.deleteCharacterCharactersDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch characters details.
         * @summary Get All Characters
         * @param {GetAllCharactersCharactersGetSortEnum} [sort] Default sort by combat total XP.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCharactersCharactersGet(sort?: GetAllCharactersCharactersGetSortEnum, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageCharacterSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCharactersCharactersGet(sort, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharactersApi.getAllCharactersCharactersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a character.
         * @summary Get Character
         * @param {string} name The character name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharacterCharactersNameGet(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharacterCharactersNameGet(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CharactersApi.getCharacterCharactersNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CharactersApi - factory interface
 * @export
 */
export const CharactersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CharactersApiFp(configuration)
    return {
        /**
         * Create new character on your account. You can create up to 5 characters.
         * @summary Create Character
         * @param {AddCharacterSchema} addCharacterSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCharacterCharactersCreatePost(addCharacterSchema: AddCharacterSchema, options?: any): AxiosPromise<CharacterResponseSchema> {
            return localVarFp.createCharacterCharactersCreatePost(addCharacterSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete character on your account.
         * @summary Delete Character
         * @param {DeleteCharacterSchema} deleteCharacterSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCharacterCharactersDeletePost(deleteCharacterSchema: DeleteCharacterSchema, options?: any): AxiosPromise<CharacterResponseSchema> {
            return localVarFp.deleteCharacterCharactersDeletePost(deleteCharacterSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch characters details.
         * @summary Get All Characters
         * @param {GetAllCharactersCharactersGetSortEnum} [sort] Default sort by combat total XP.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCharactersCharactersGet(sort?: GetAllCharactersCharactersGetSortEnum, page?: number, size?: number, options?: any): AxiosPromise<DataPageCharacterSchema> {
            return localVarFp.getAllCharactersCharactersGet(sort, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a character.
         * @summary Get Character
         * @param {string} name The character name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharacterCharactersNameGet(name: string, options?: any): AxiosPromise<CharacterResponseSchema> {
            return localVarFp.getCharacterCharactersNameGet(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CharactersApi - object-oriented interface
 * @export
 * @class CharactersApi
 * @extends {BaseAPI}
 */
export class CharactersApi extends BaseAPI {
    /**
     * Create new character on your account. You can create up to 5 characters.
     * @summary Create Character
     * @param {AddCharacterSchema} addCharacterSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharactersApi
     */
    public createCharacterCharactersCreatePost(addCharacterSchema: AddCharacterSchema, options?: RawAxiosRequestConfig) {
        return CharactersApiFp(this.configuration).createCharacterCharactersCreatePost(addCharacterSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete character on your account.
     * @summary Delete Character
     * @param {DeleteCharacterSchema} deleteCharacterSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharactersApi
     */
    public deleteCharacterCharactersDeletePost(deleteCharacterSchema: DeleteCharacterSchema, options?: RawAxiosRequestConfig) {
        return CharactersApiFp(this.configuration).deleteCharacterCharactersDeletePost(deleteCharacterSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch characters details.
     * @summary Get All Characters
     * @param {GetAllCharactersCharactersGetSortEnum} [sort] Default sort by combat total XP.
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharactersApi
     */
    public getAllCharactersCharactersGet(sort?: GetAllCharactersCharactersGetSortEnum, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return CharactersApiFp(this.configuration).getAllCharactersCharactersGet(sort, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a character.
     * @summary Get Character
     * @param {string} name The character name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CharactersApi
     */
    public getCharacterCharactersNameGet(name: string, options?: RawAxiosRequestConfig) {
        return CharactersApiFp(this.configuration).getCharacterCharactersNameGet(name, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllCharactersCharactersGetSortEnum = {
    Woodcutting: 'woodcutting',
    Mining: 'mining',
    Fishing: 'fishing',
    Weaponcrafting: 'weaponcrafting',
    Gearcrafting: 'gearcrafting',
    Jewelrycrafting: 'jewelrycrafting',
    Cooking: 'cooking',
    Gold: 'gold'
} as const;
export type GetAllCharactersCharactersGetSortEnum = typeof GetAllCharactersCharactersGetSortEnum[keyof typeof GetAllCharactersCharactersGetSortEnum];


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the status of the game server.
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the status of the game server.
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Return the status of the game server.
         * @summary Get Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusGet(options?: any): AxiosPromise<StatusResponseSchema> {
            return localVarFp.getStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Return the status of the game server.
     * @summary Get Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatusGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch events details.
         * @summary Get All Events
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsEventsGet: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch events details.
         * @summary Get All Events
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEventsEventsGet(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageActiveEventSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEventsEventsGet(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getAllEventsEventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Fetch events details.
         * @summary Get All Events
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEventsEventsGet(page?: number, size?: number, options?: any): AxiosPromise<DataPageActiveEventSchema> {
            return localVarFp.getAllEventsEventsGet(page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Fetch events details.
     * @summary Get All Events
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getAllEventsEventsGet(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getAllEventsEventsGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GrandExchangeApi - axios parameter creator
 * @export
 */
export const GrandExchangeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch Grand Exchange items details.
         * @summary Get All Ge Items
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGeItemsGeGet: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ge/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a Grand Exchange item.
         * @summary Get Ge Item
         * @param {string} code The code of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeItemGeCodeGet: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getGeItemGeCodeGet', 'code', code)
            const localVarPath = `/ge/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GrandExchangeApi - functional programming interface
 * @export
 */
export const GrandExchangeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GrandExchangeApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch Grand Exchange items details.
         * @summary Get All Ge Items
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllGeItemsGeGet(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageGEItemSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllGeItemsGeGet(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GrandExchangeApi.getAllGeItemsGeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a Grand Exchange item.
         * @summary Get Ge Item
         * @param {string} code The code of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeItemGeCodeGet(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GEItemResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeItemGeCodeGet(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GrandExchangeApi.getGeItemGeCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GrandExchangeApi - factory interface
 * @export
 */
export const GrandExchangeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GrandExchangeApiFp(configuration)
    return {
        /**
         * Fetch Grand Exchange items details.
         * @summary Get All Ge Items
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGeItemsGeGet(page?: number, size?: number, options?: any): AxiosPromise<DataPageGEItemSchema> {
            return localVarFp.getAllGeItemsGeGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a Grand Exchange item.
         * @summary Get Ge Item
         * @param {string} code The code of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeItemGeCodeGet(code: string, options?: any): AxiosPromise<GEItemResponseSchema> {
            return localVarFp.getGeItemGeCodeGet(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GrandExchangeApi - object-oriented interface
 * @export
 * @class GrandExchangeApi
 * @extends {BaseAPI}
 */
export class GrandExchangeApi extends BaseAPI {
    /**
     * Fetch Grand Exchange items details.
     * @summary Get All Ge Items
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrandExchangeApi
     */
    public getAllGeItemsGeGet(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return GrandExchangeApiFp(this.configuration).getAllGeItemsGeGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a Grand Exchange item.
     * @summary Get Ge Item
     * @param {string} code The code of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GrandExchangeApi
     */
    public getGeItemGeCodeGet(code: string, options?: RawAxiosRequestConfig) {
        return GrandExchangeApiFp(this.configuration).getGeItemGeCodeGet(code, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch items details.
         * @summary Get All Items
         * @param {number} [minLevel] Minimum level items.
         * @param {number} [maxLevel] Maximum level items.
         * @param {string} [name] Name of the item.
         * @param {GetAllItemsItemsGetTypeEnum} [type] Type of items.
         * @param {GetAllItemsItemsGetCraftSkillEnum} [craftSkill] Skill to craft items.
         * @param {string} [craftMaterial] Item code of items used as material for crafting.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsItemsGet: async (minLevel?: number, maxLevel?: number, name?: string, type?: GetAllItemsItemsGetTypeEnum, craftSkill?: GetAllItemsItemsGetCraftSkillEnum, craftMaterial?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minLevel !== undefined) {
                localVarQueryParameter['min_level'] = minLevel;
            }

            if (maxLevel !== undefined) {
                localVarQueryParameter['max_level'] = maxLevel;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (craftSkill !== undefined) {
                localVarQueryParameter['craft_skill'] = craftSkill;
            }

            if (craftMaterial !== undefined) {
                localVarQueryParameter['craft_material'] = craftMaterial;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a item.
         * @summary Get Item
         * @param {string} code The code of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemItemsCodeGet: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getItemItemsCodeGet', 'code', code)
            const localVarPath = `/items/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch items details.
         * @summary Get All Items
         * @param {number} [minLevel] Minimum level items.
         * @param {number} [maxLevel] Maximum level items.
         * @param {string} [name] Name of the item.
         * @param {GetAllItemsItemsGetTypeEnum} [type] Type of items.
         * @param {GetAllItemsItemsGetCraftSkillEnum} [craftSkill] Skill to craft items.
         * @param {string} [craftMaterial] Item code of items used as material for crafting.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllItemsItemsGet(minLevel?: number, maxLevel?: number, name?: string, type?: GetAllItemsItemsGetTypeEnum, craftSkill?: GetAllItemsItemsGetCraftSkillEnum, craftMaterial?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageItemSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllItemsItemsGet(minLevel, maxLevel, name, type, craftSkill, craftMaterial, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getAllItemsItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a item.
         * @summary Get Item
         * @param {string} code The code of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemItemsCodeGet(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemItemsCodeGet(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemItemsCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Fetch items details.
         * @summary Get All Items
         * @param {number} [minLevel] Minimum level items.
         * @param {number} [maxLevel] Maximum level items.
         * @param {string} [name] Name of the item.
         * @param {GetAllItemsItemsGetTypeEnum} [type] Type of items.
         * @param {GetAllItemsItemsGetCraftSkillEnum} [craftSkill] Skill to craft items.
         * @param {string} [craftMaterial] Item code of items used as material for crafting.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllItemsItemsGet(minLevel?: number, maxLevel?: number, name?: string, type?: GetAllItemsItemsGetTypeEnum, craftSkill?: GetAllItemsItemsGetCraftSkillEnum, craftMaterial?: string, page?: number, size?: number, options?: any): AxiosPromise<DataPageItemSchema> {
            return localVarFp.getAllItemsItemsGet(minLevel, maxLevel, name, type, craftSkill, craftMaterial, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a item.
         * @summary Get Item
         * @param {string} code The code of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemItemsCodeGet(code: string, options?: any): AxiosPromise<ItemResponseSchema> {
            return localVarFp.getItemItemsCodeGet(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Fetch items details.
     * @summary Get All Items
     * @param {number} [minLevel] Minimum level items.
     * @param {number} [maxLevel] Maximum level items.
     * @param {string} [name] Name of the item.
     * @param {GetAllItemsItemsGetTypeEnum} [type] Type of items.
     * @param {GetAllItemsItemsGetCraftSkillEnum} [craftSkill] Skill to craft items.
     * @param {string} [craftMaterial] Item code of items used as material for crafting.
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getAllItemsItemsGet(minLevel?: number, maxLevel?: number, name?: string, type?: GetAllItemsItemsGetTypeEnum, craftSkill?: GetAllItemsItemsGetCraftSkillEnum, craftMaterial?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getAllItemsItemsGet(minLevel, maxLevel, name, type, craftSkill, craftMaterial, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a item.
     * @summary Get Item
     * @param {string} code The code of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItemItemsCodeGet(code: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemItemsCodeGet(code, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllItemsItemsGetTypeEnum = {
    Consumable: 'consumable',
    BodyArmor: 'body_armor',
    Weapon: 'weapon',
    Resource: 'resource',
    LegArmor: 'leg_armor',
    Helmet: 'helmet',
    Boots: 'boots',
    Shield: 'shield',
    Amulet: 'amulet',
    Ring: 'ring'
} as const;
export type GetAllItemsItemsGetTypeEnum = typeof GetAllItemsItemsGetTypeEnum[keyof typeof GetAllItemsItemsGetTypeEnum];
/**
 * @export
 */
export const GetAllItemsItemsGetCraftSkillEnum = {
    Weaponcrafting: 'weaponcrafting',
    Gearcrafting: 'gearcrafting',
    Jewelrycrafting: 'jewelrycrafting',
    Cooking: 'cooking',
    Woodcutting: 'woodcutting',
    Mining: 'mining'
} as const;
export type GetAllItemsItemsGetCraftSkillEnum = typeof GetAllItemsItemsGetCraftSkillEnum[keyof typeof GetAllItemsItemsGetCraftSkillEnum];


/**
 * MapsApi - axios parameter creator
 * @export
 */
export const MapsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch maps details.
         * @summary Get All Maps
         * @param {GetAllMapsMapsGetContentTypeEnum} [contentType] Type of content on the map.
         * @param {string} [contentCode] Content code on the map.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMapsMapsGet: async (contentType?: GetAllMapsMapsGetContentTypeEnum, contentCode?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/maps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (contentCode !== undefined) {
                localVarQueryParameter['content_code'] = contentCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a map.
         * @summary Get Map
         * @param {number} x The position x of the map.
         * @param {number} y The position X of the map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapMapsXYGet: async (x: number, y: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x' is not null or undefined
            assertParamExists('getMapMapsXYGet', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('getMapMapsXYGet', 'y', y)
            const localVarPath = `/maps/{x}/{y}`
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MapsApi - functional programming interface
 * @export
 */
export const MapsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MapsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch maps details.
         * @summary Get All Maps
         * @param {GetAllMapsMapsGetContentTypeEnum} [contentType] Type of content on the map.
         * @param {string} [contentCode] Content code on the map.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMapsMapsGet(contentType?: GetAllMapsMapsGetContentTypeEnum, contentCode?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageMapSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMapsMapsGet(contentType, contentCode, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MapsApi.getAllMapsMapsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a map.
         * @summary Get Map
         * @param {number} x The position x of the map.
         * @param {number} y The position X of the map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMapMapsXYGet(x: number, y: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMapMapsXYGet(x, y, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MapsApi.getMapMapsXYGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MapsApi - factory interface
 * @export
 */
export const MapsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MapsApiFp(configuration)
    return {
        /**
         * Fetch maps details.
         * @summary Get All Maps
         * @param {GetAllMapsMapsGetContentTypeEnum} [contentType] Type of content on the map.
         * @param {string} [contentCode] Content code on the map.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMapsMapsGet(contentType?: GetAllMapsMapsGetContentTypeEnum, contentCode?: string, page?: number, size?: number, options?: any): AxiosPromise<DataPageMapSchema> {
            return localVarFp.getAllMapsMapsGet(contentType, contentCode, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a map.
         * @summary Get Map
         * @param {number} x The position x of the map.
         * @param {number} y The position X of the map.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapMapsXYGet(x: number, y: number, options?: any): AxiosPromise<MapResponseSchema> {
            return localVarFp.getMapMapsXYGet(x, y, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MapsApi - object-oriented interface
 * @export
 * @class MapsApi
 * @extends {BaseAPI}
 */
export class MapsApi extends BaseAPI {
    /**
     * Fetch maps details.
     * @summary Get All Maps
     * @param {GetAllMapsMapsGetContentTypeEnum} [contentType] Type of content on the map.
     * @param {string} [contentCode] Content code on the map.
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapsApi
     */
    public getAllMapsMapsGet(contentType?: GetAllMapsMapsGetContentTypeEnum, contentCode?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return MapsApiFp(this.configuration).getAllMapsMapsGet(contentType, contentCode, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a map.
     * @summary Get Map
     * @param {number} x The position x of the map.
     * @param {number} y The position X of the map.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapsApi
     */
    public getMapMapsXYGet(x: number, y: number, options?: RawAxiosRequestConfig) {
        return MapsApiFp(this.configuration).getMapMapsXYGet(x, y, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllMapsMapsGetContentTypeEnum = {
    Monster: 'monster',
    Resource: 'resource',
    Workshop: 'workshop',
    Bank: 'bank',
    GrandExchange: 'grand_exchange',
    TasksMaster: 'tasks_master'
} as const;
export type GetAllMapsMapsGetContentTypeEnum = typeof GetAllMapsMapsGetContentTypeEnum[keyof typeof GetAllMapsMapsGetContentTypeEnum];


/**
 * MonstersApi - axios parameter creator
 * @export
 */
export const MonstersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch monsters details.
         * @summary Get All Monsters
         * @param {number} [minLevel] Monster minimum level.
         * @param {number} [maxLevel] Monster maximum level.
         * @param {string} [drop] Item code of the drop.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMonstersMonstersGet: async (minLevel?: number, maxLevel?: number, drop?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/monsters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minLevel !== undefined) {
                localVarQueryParameter['min_level'] = minLevel;
            }

            if (maxLevel !== undefined) {
                localVarQueryParameter['max_level'] = maxLevel;
            }

            if (drop !== undefined) {
                localVarQueryParameter['drop'] = drop;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a monster.
         * @summary Get Monster
         * @param {string} code The code of the monster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonsterMonstersCodeGet: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getMonsterMonstersCodeGet', 'code', code)
            const localVarPath = `/monsters/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonstersApi - functional programming interface
 * @export
 */
export const MonstersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonstersApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch monsters details.
         * @summary Get All Monsters
         * @param {number} [minLevel] Monster minimum level.
         * @param {number} [maxLevel] Monster maximum level.
         * @param {string} [drop] Item code of the drop.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMonstersMonstersGet(minLevel?: number, maxLevel?: number, drop?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageMonsterSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMonstersMonstersGet(minLevel, maxLevel, drop, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MonstersApi.getAllMonstersMonstersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a monster.
         * @summary Get Monster
         * @param {string} code The code of the monster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonsterMonstersCodeGet(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MonsterResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonsterMonstersCodeGet(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MonstersApi.getMonsterMonstersCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MonstersApi - factory interface
 * @export
 */
export const MonstersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonstersApiFp(configuration)
    return {
        /**
         * Fetch monsters details.
         * @summary Get All Monsters
         * @param {number} [minLevel] Monster minimum level.
         * @param {number} [maxLevel] Monster maximum level.
         * @param {string} [drop] Item code of the drop.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMonstersMonstersGet(minLevel?: number, maxLevel?: number, drop?: string, page?: number, size?: number, options?: any): AxiosPromise<DataPageMonsterSchema> {
            return localVarFp.getAllMonstersMonstersGet(minLevel, maxLevel, drop, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a monster.
         * @summary Get Monster
         * @param {string} code The code of the monster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonsterMonstersCodeGet(code: string, options?: any): AxiosPromise<MonsterResponseSchema> {
            return localVarFp.getMonsterMonstersCodeGet(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonstersApi - object-oriented interface
 * @export
 * @class MonstersApi
 * @extends {BaseAPI}
 */
export class MonstersApi extends BaseAPI {
    /**
     * Fetch monsters details.
     * @summary Get All Monsters
     * @param {number} [minLevel] Monster minimum level.
     * @param {number} [maxLevel] Monster maximum level.
     * @param {string} [drop] Item code of the drop.
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonstersApi
     */
    public getAllMonstersMonstersGet(minLevel?: number, maxLevel?: number, drop?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return MonstersApiFp(this.configuration).getAllMonstersMonstersGet(minLevel, maxLevel, drop, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a monster.
     * @summary Get Monster
     * @param {string} code The code of the monster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonstersApi
     */
    public getMonsterMonstersCodeGet(code: string, options?: RawAxiosRequestConfig) {
        return MonstersApiFp(this.configuration).getMonsterMonstersCodeGet(code, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MyAccountApi - axios parameter creator
 * @export
 */
export const MyAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change your account password. Changing the password reset the account token.
         * @summary Change Password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordMyChangePasswordPost: async (changePassword: ChangePassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePassword' is not null or undefined
            assertParamExists('changePasswordMyChangePasswordPost', 'changePassword', changePassword)
            const localVarPath = `/my/change_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch golds in your bank.
         * @summary Get Bank Golds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankGoldsMyBankGoldGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/bank/gold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all items in your bank.
         * @summary Get Bank Items
         * @param {string} [itemCode] Item to search in your bank.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankItemsMyBankItemsGet: async (itemCode?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/bank/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (itemCode !== undefined) {
                localVarQueryParameter['item_code'] = itemCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyAccountApi - functional programming interface
 * @export
 */
export const MyAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Change your account password. Changing the password reset the account token.
         * @summary Change Password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePasswordMyChangePasswordPost(changePassword: ChangePassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePasswordMyChangePasswordPost(changePassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyAccountApi.changePasswordMyChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch golds in your bank.
         * @summary Get Bank Golds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankGoldsMyBankGoldGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoldBankResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankGoldsMyBankGoldGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyAccountApi.getBankGoldsMyBankGoldGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch all items in your bank.
         * @summary Get Bank Items
         * @param {string} [itemCode] Item to search in your bank.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankItemsMyBankItemsGet(itemCode?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageSimpleItemSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankItemsMyBankItemsGet(itemCode, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyAccountApi.getBankItemsMyBankItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MyAccountApi - factory interface
 * @export
 */
export const MyAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyAccountApiFp(configuration)
    return {
        /**
         * Change your account password. Changing the password reset the account token.
         * @summary Change Password
         * @param {ChangePassword} changePassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordMyChangePasswordPost(changePassword: ChangePassword, options?: any): AxiosPromise<ResponseSchema> {
            return localVarFp.changePasswordMyChangePasswordPost(changePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch golds in your bank.
         * @summary Get Bank Golds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankGoldsMyBankGoldGet(options?: any): AxiosPromise<GoldBankResponseSchema> {
            return localVarFp.getBankGoldsMyBankGoldGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all items in your bank.
         * @summary Get Bank Items
         * @param {string} [itemCode] Item to search in your bank.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankItemsMyBankItemsGet(itemCode?: string, page?: number, size?: number, options?: any): AxiosPromise<DataPageSimpleItemSchema> {
            return localVarFp.getBankItemsMyBankItemsGet(itemCode, page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MyAccountApi - object-oriented interface
 * @export
 * @class MyAccountApi
 * @extends {BaseAPI}
 */
export class MyAccountApi extends BaseAPI {
    /**
     * Change your account password. Changing the password reset the account token.
     * @summary Change Password
     * @param {ChangePassword} changePassword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyAccountApi
     */
    public changePasswordMyChangePasswordPost(changePassword: ChangePassword, options?: RawAxiosRequestConfig) {
        return MyAccountApiFp(this.configuration).changePasswordMyChangePasswordPost(changePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch golds in your bank.
     * @summary Get Bank Golds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyAccountApi
     */
    public getBankGoldsMyBankGoldGet(options?: RawAxiosRequestConfig) {
        return MyAccountApiFp(this.configuration).getBankGoldsMyBankGoldGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all items in your bank.
     * @summary Get Bank Items
     * @param {string} [itemCode] Item to search in your bank.
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyAccountApi
     */
    public getBankItemsMyBankItemsGet(itemCode?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return MyAccountApiFp(this.configuration).getBankItemsMyBankItemsGet(itemCode, page, size, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MyCharactersApi - axios parameter creator
 * @export
 */
export const MyCharactersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepting a new task.
         * @summary Action Accept New Task
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionAcceptNewTaskMyNameActionTaskNewPost: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionAcceptNewTaskMyNameActionTaskNewPost', 'name', name)
            const localVarPath = `/my/{name}/action/task/new`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete a task.
         * @summary Action Complete Task
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCompleteTaskMyNameActionTaskCompletePost: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionCompleteTaskMyNameActionTaskCompletePost', 'name', name)
            const localVarPath = `/my/{name}/action/task/complete`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crafting an item. The character must be on a map with a workshop.
         * @summary Action Crafting
         * @param {string} name Name of your character.
         * @param {CraftingSchema} craftingSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCraftingMyNameActionCraftingPost: async (name: string, craftingSchema: CraftingSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionCraftingMyNameActionCraftingPost', 'name', name)
            // verify required parameter 'craftingSchema' is not null or undefined
            assertParamExists('actionCraftingMyNameActionCraftingPost', 'craftingSchema', craftingSchema)
            const localVarPath = `/my/{name}/action/crafting`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(craftingSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an item from your character\'s inventory.
         * @summary Action Delete Item
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionDeleteItemMyNameActionDeletePost: async (name: string, simpleItemSchema: SimpleItemSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionDeleteItemMyNameActionDeletePost', 'name', name)
            // verify required parameter 'simpleItemSchema' is not null or undefined
            assertParamExists('actionDeleteItemMyNameActionDeletePost', 'simpleItemSchema', simpleItemSchema)
            const localVarPath = `/my/{name}/action/delete`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleItemSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deposit golds in a bank on the character\'s map.
         * @summary Action Deposit Bank Gold
         * @param {string} name Name of your character.
         * @param {DepositWithdrawGoldSchema} depositWithdrawGoldSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionDepositBankGoldMyNameActionBankDepositGoldPost: async (name: string, depositWithdrawGoldSchema: DepositWithdrawGoldSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionDepositBankGoldMyNameActionBankDepositGoldPost', 'name', name)
            // verify required parameter 'depositWithdrawGoldSchema' is not null or undefined
            assertParamExists('actionDepositBankGoldMyNameActionBankDepositGoldPost', 'depositWithdrawGoldSchema', depositWithdrawGoldSchema)
            const localVarPath = `/my/{name}/action/bank/deposit/gold`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depositWithdrawGoldSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deposit an item in a bank on the character\'s map.
         * @summary Action Deposit Bank
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionDepositBankMyNameActionBankDepositPost: async (name: string, simpleItemSchema: SimpleItemSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionDepositBankMyNameActionBankDepositPost', 'name', name)
            // verify required parameter 'simpleItemSchema' is not null or undefined
            assertParamExists('actionDepositBankMyNameActionBankDepositPost', 'simpleItemSchema', simpleItemSchema)
            const localVarPath = `/my/{name}/action/bank/deposit`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleItemSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Equip an item on your character.
         * @summary Action Equip Item
         * @param {string} name Name of your character.
         * @param {EquipSchema} equipSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionEquipItemMyNameActionEquipPost: async (name: string, equipSchema: EquipSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionEquipItemMyNameActionEquipPost', 'name', name)
            // verify required parameter 'equipSchema' is not null or undefined
            assertParamExists('actionEquipItemMyNameActionEquipPost', 'equipSchema', equipSchema)
            const localVarPath = `/my/{name}/action/equip`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(equipSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a fight against a monster on the character\'s map.
         * @summary Action Fight
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionFightMyNameActionFightPost: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionFightMyNameActionFightPost', 'name', name)
            const localVarPath = `/my/{name}/action/fight`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Harvest a resource on the character\'s map.
         * @summary Action Gathering
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGatheringMyNameActionGatheringPost: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionGatheringMyNameActionGatheringPost', 'name', name)
            const localVarPath = `/my/{name}/action/gathering`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Buy an item at the Grand Exchange on the character\'s map.
         * @summary Action Ge Buy Item
         * @param {string} name Name of your character.
         * @param {GETransactionItemSchema} gETransactionItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGeBuyItemMyNameActionGeBuyPost: async (name: string, gETransactionItemSchema: GETransactionItemSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionGeBuyItemMyNameActionGeBuyPost', 'name', name)
            // verify required parameter 'gETransactionItemSchema' is not null or undefined
            assertParamExists('actionGeBuyItemMyNameActionGeBuyPost', 'gETransactionItemSchema', gETransactionItemSchema)
            const localVarPath = `/my/{name}/action/ge/buy`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gETransactionItemSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sell an item at the Grand Exchange on the character\'s map.
         * @summary Action Ge Sell Item
         * @param {string} name Name of your character.
         * @param {GETransactionItemSchema} gETransactionItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGeSellItemMyNameActionGeSellPost: async (name: string, gETransactionItemSchema: GETransactionItemSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionGeSellItemMyNameActionGeSellPost', 'name', name)
            // verify required parameter 'gETransactionItemSchema' is not null or undefined
            assertParamExists('actionGeSellItemMyNameActionGeSellPost', 'gETransactionItemSchema', gETransactionItemSchema)
            const localVarPath = `/my/{name}/action/ge/sell`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gETransactionItemSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves a character on the map using the map\'s X and Y position.
         * @summary Action Move
         * @param {string} name Name of your character.
         * @param {DestinationSchema} destinationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionMoveMyNameActionMovePost: async (name: string, destinationSchema: DestinationSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionMoveMyNameActionMovePost', 'name', name)
            // verify required parameter 'destinationSchema' is not null or undefined
            assertParamExists('actionMoveMyNameActionMovePost', 'destinationSchema', destinationSchema)
            const localVarPath = `/my/{name}/action/move`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(destinationSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).
         * @summary Action Recycling
         * @param {string} name Name of your character.
         * @param {RecyclingSchema} recyclingSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionRecyclingMyNameActionRecyclingPost: async (name: string, recyclingSchema: RecyclingSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionRecyclingMyNameActionRecyclingPost', 'name', name)
            // verify required parameter 'recyclingSchema' is not null or undefined
            assertParamExists('actionRecyclingMyNameActionRecyclingPost', 'recyclingSchema', recyclingSchema)
            const localVarPath = `/my/{name}/action/recycling`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recyclingSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.
         * @summary Action Task Exchange
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionTaskExchangeMyNameActionTaskExchangePost: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionTaskExchangeMyNameActionTaskExchangePost', 'name', name)
            const localVarPath = `/my/{name}/action/task/exchange`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unequip an item on your character.
         * @summary Action Unequip Item
         * @param {string} name Name of your character.
         * @param {UnequipSchema} unequipSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionUnequipItemMyNameActionUnequipPost: async (name: string, unequipSchema: UnequipSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionUnequipItemMyNameActionUnequipPost', 'name', name)
            // verify required parameter 'unequipSchema' is not null or undefined
            assertParamExists('actionUnequipItemMyNameActionUnequipPost', 'unequipSchema', unequipSchema)
            const localVarPath = `/my/{name}/action/unequip`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unequipSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw gold from your bank.
         * @summary Action Withdraw Bank Gold
         * @param {string} name Name of your character.
         * @param {DepositWithdrawGoldSchema} depositWithdrawGoldSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost: async (name: string, depositWithdrawGoldSchema: DepositWithdrawGoldSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost', 'name', name)
            // verify required parameter 'depositWithdrawGoldSchema' is not null or undefined
            assertParamExists('actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost', 'depositWithdrawGoldSchema', depositWithdrawGoldSchema)
            const localVarPath = `/my/{name}/action/bank/withdraw/gold`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depositWithdrawGoldSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Take an item from your bank and put it in the character\'s inventory.
         * @summary Action Withdraw Bank
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionWithdrawBankMyNameActionBankWithdrawPost: async (name: string, simpleItemSchema: SimpleItemSchema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('actionWithdrawBankMyNameActionBankWithdrawPost', 'name', name)
            // verify required parameter 'simpleItemSchema' is not null or undefined
            assertParamExists('actionWithdrawBankMyNameActionBankWithdrawPost', 'simpleItemSchema', simpleItemSchema)
            const localVarPath = `/my/{name}/action/bank/withdraw`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simpleItemSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * History of the last 100 actions of all your characters.
         * @summary Get All Characters Logs
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCharactersLogsMyLogsGet: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of your characters.
         * @summary Get My Characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyCharactersMyCharactersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/my/characters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWTBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MyCharactersApi - functional programming interface
 * @export
 */
export const MyCharactersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MyCharactersApiAxiosParamCreator(configuration)
    return {
        /**
         * Accepting a new task.
         * @summary Action Accept New Task
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionAcceptNewTaskMyNameActionTaskNewPost(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionAcceptNewTaskMyNameActionTaskNewPost(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionAcceptNewTaskMyNameActionTaskNewPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete a task.
         * @summary Action Complete Task
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCompleteTaskMyNameActionTaskCompletePost(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRewardResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCompleteTaskMyNameActionTaskCompletePost(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionCompleteTaskMyNameActionTaskCompletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crafting an item. The character must be on a map with a workshop.
         * @summary Action Crafting
         * @param {string} name Name of your character.
         * @param {CraftingSchema} craftingSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionCraftingMyNameActionCraftingPost(name: string, craftingSchema: CraftingSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionCraftingMyNameActionCraftingPost(name, craftingSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionCraftingMyNameActionCraftingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an item from your character\'s inventory.
         * @summary Action Delete Item
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionDeleteItemMyNameActionDeletePost(name: string, simpleItemSchema: SimpleItemSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteItemResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionDeleteItemMyNameActionDeletePost(name, simpleItemSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionDeleteItemMyNameActionDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deposit golds in a bank on the character\'s map.
         * @summary Action Deposit Bank Gold
         * @param {string} name Name of your character.
         * @param {DepositWithdrawGoldSchema} depositWithdrawGoldSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionDepositBankGoldMyNameActionBankDepositGoldPost(name: string, depositWithdrawGoldSchema: DepositWithdrawGoldSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoldResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionDepositBankGoldMyNameActionBankDepositGoldPost(name, depositWithdrawGoldSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionDepositBankGoldMyNameActionBankDepositGoldPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deposit an item in a bank on the character\'s map.
         * @summary Action Deposit Bank
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionDepositBankMyNameActionBankDepositPost(name: string, simpleItemSchema: SimpleItemSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionItemBankResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionDepositBankMyNameActionBankDepositPost(name, simpleItemSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionDepositBankMyNameActionBankDepositPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Equip an item on your character.
         * @summary Action Equip Item
         * @param {string} name Name of your character.
         * @param {EquipSchema} equipSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionEquipItemMyNameActionEquipPost(name: string, equipSchema: EquipSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionEquipItemMyNameActionEquipPost(name, equipSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionEquipItemMyNameActionEquipPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a fight against a monster on the character\'s map.
         * @summary Action Fight
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionFightMyNameActionFightPost(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterFightResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionFightMyNameActionFightPost(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionFightMyNameActionFightPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Harvest a resource on the character\'s map.
         * @summary Action Gathering
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGatheringMyNameActionGatheringPost(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGatheringMyNameActionGatheringPost(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionGatheringMyNameActionGatheringPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Buy an item at the Grand Exchange on the character\'s map.
         * @summary Action Ge Buy Item
         * @param {string} name Name of your character.
         * @param {GETransactionItemSchema} gETransactionItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGeBuyItemMyNameActionGeBuyPost(name: string, gETransactionItemSchema: GETransactionItemSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETransactionResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGeBuyItemMyNameActionGeBuyPost(name, gETransactionItemSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionGeBuyItemMyNameActionGeBuyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sell an item at the Grand Exchange on the character\'s map.
         * @summary Action Ge Sell Item
         * @param {string} name Name of your character.
         * @param {GETransactionItemSchema} gETransactionItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionGeSellItemMyNameActionGeSellPost(name: string, gETransactionItemSchema: GETransactionItemSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GETransactionResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionGeSellItemMyNameActionGeSellPost(name, gETransactionItemSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionGeSellItemMyNameActionGeSellPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Moves a character on the map using the map\'s X and Y position.
         * @summary Action Move
         * @param {string} name Name of your character.
         * @param {DestinationSchema} destinationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionMoveMyNameActionMovePost(name: string, destinationSchema: DestinationSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CharacterMovementResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionMoveMyNameActionMovePost(name, destinationSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionMoveMyNameActionMovePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).
         * @summary Action Recycling
         * @param {string} name Name of your character.
         * @param {RecyclingSchema} recyclingSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionRecyclingMyNameActionRecyclingPost(name: string, recyclingSchema: RecyclingSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecyclingResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionRecyclingMyNameActionRecyclingPost(name, recyclingSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionRecyclingMyNameActionRecyclingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.
         * @summary Action Task Exchange
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionTaskExchangeMyNameActionTaskExchangePost(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRewardResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionTaskExchangeMyNameActionTaskExchangePost(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionTaskExchangeMyNameActionTaskExchangePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unequip an item on your character.
         * @summary Action Unequip Item
         * @param {string} name Name of your character.
         * @param {UnequipSchema} unequipSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionUnequipItemMyNameActionUnequipPost(name: string, unequipSchema: UnequipSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EquipmentResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionUnequipItemMyNameActionUnequipPost(name, unequipSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionUnequipItemMyNameActionUnequipPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Withdraw gold from your bank.
         * @summary Action Withdraw Bank Gold
         * @param {string} name Name of your character.
         * @param {DepositWithdrawGoldSchema} depositWithdrawGoldSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(name: string, depositWithdrawGoldSchema: DepositWithdrawGoldSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GoldResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(name, depositWithdrawGoldSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Take an item from your bank and put it in the character\'s inventory.
         * @summary Action Withdraw Bank
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionWithdrawBankMyNameActionBankWithdrawPost(name: string, simpleItemSchema: SimpleItemSchema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionItemBankResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionWithdrawBankMyNameActionBankWithdrawPost(name, simpleItemSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.actionWithdrawBankMyNameActionBankWithdrawPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * History of the last 100 actions of all your characters.
         * @summary Get All Characters Logs
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCharactersLogsMyLogsGet(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageLogSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCharactersLogsMyLogsGet(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.getAllCharactersLogsMyLogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of your characters.
         * @summary Get My Characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyCharactersMyCharactersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MyCharactersListSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyCharactersMyCharactersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MyCharactersApi.getMyCharactersMyCharactersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MyCharactersApi - factory interface
 * @export
 */
export const MyCharactersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MyCharactersApiFp(configuration)
    return {
        /**
         * Accepting a new task.
         * @summary Action Accept New Task
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionAcceptNewTaskMyNameActionTaskNewPost(name: string, options?: any): AxiosPromise<TaskResponseSchema> {
            return localVarFp.actionAcceptNewTaskMyNameActionTaskNewPost(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete a task.
         * @summary Action Complete Task
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCompleteTaskMyNameActionTaskCompletePost(name: string, options?: any): AxiosPromise<TaskRewardResponseSchema> {
            return localVarFp.actionCompleteTaskMyNameActionTaskCompletePost(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Crafting an item. The character must be on a map with a workshop.
         * @summary Action Crafting
         * @param {string} name Name of your character.
         * @param {CraftingSchema} craftingSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionCraftingMyNameActionCraftingPost(name: string, craftingSchema: CraftingSchema, options?: any): AxiosPromise<SkillResponseSchema> {
            return localVarFp.actionCraftingMyNameActionCraftingPost(name, craftingSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an item from your character\'s inventory.
         * @summary Action Delete Item
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionDeleteItemMyNameActionDeletePost(name: string, simpleItemSchema: SimpleItemSchema, options?: any): AxiosPromise<DeleteItemResponseSchema> {
            return localVarFp.actionDeleteItemMyNameActionDeletePost(name, simpleItemSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Deposit golds in a bank on the character\'s map.
         * @summary Action Deposit Bank Gold
         * @param {string} name Name of your character.
         * @param {DepositWithdrawGoldSchema} depositWithdrawGoldSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionDepositBankGoldMyNameActionBankDepositGoldPost(name: string, depositWithdrawGoldSchema: DepositWithdrawGoldSchema, options?: any): AxiosPromise<GoldResponseSchema> {
            return localVarFp.actionDepositBankGoldMyNameActionBankDepositGoldPost(name, depositWithdrawGoldSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Deposit an item in a bank on the character\'s map.
         * @summary Action Deposit Bank
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionDepositBankMyNameActionBankDepositPost(name: string, simpleItemSchema: SimpleItemSchema, options?: any): AxiosPromise<ActionItemBankResponseSchema> {
            return localVarFp.actionDepositBankMyNameActionBankDepositPost(name, simpleItemSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Equip an item on your character.
         * @summary Action Equip Item
         * @param {string} name Name of your character.
         * @param {EquipSchema} equipSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionEquipItemMyNameActionEquipPost(name: string, equipSchema: EquipSchema, options?: any): AxiosPromise<EquipmentResponseSchema> {
            return localVarFp.actionEquipItemMyNameActionEquipPost(name, equipSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a fight against a monster on the character\'s map.
         * @summary Action Fight
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionFightMyNameActionFightPost(name: string, options?: any): AxiosPromise<CharacterFightResponseSchema> {
            return localVarFp.actionFightMyNameActionFightPost(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Harvest a resource on the character\'s map.
         * @summary Action Gathering
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGatheringMyNameActionGatheringPost(name: string, options?: any): AxiosPromise<SkillResponseSchema> {
            return localVarFp.actionGatheringMyNameActionGatheringPost(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Buy an item at the Grand Exchange on the character\'s map.
         * @summary Action Ge Buy Item
         * @param {string} name Name of your character.
         * @param {GETransactionItemSchema} gETransactionItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGeBuyItemMyNameActionGeBuyPost(name: string, gETransactionItemSchema: GETransactionItemSchema, options?: any): AxiosPromise<GETransactionResponseSchema> {
            return localVarFp.actionGeBuyItemMyNameActionGeBuyPost(name, gETransactionItemSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Sell an item at the Grand Exchange on the character\'s map.
         * @summary Action Ge Sell Item
         * @param {string} name Name of your character.
         * @param {GETransactionItemSchema} gETransactionItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionGeSellItemMyNameActionGeSellPost(name: string, gETransactionItemSchema: GETransactionItemSchema, options?: any): AxiosPromise<GETransactionResponseSchema> {
            return localVarFp.actionGeSellItemMyNameActionGeSellPost(name, gETransactionItemSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Moves a character on the map using the map\'s X and Y position.
         * @summary Action Move
         * @param {string} name Name of your character.
         * @param {DestinationSchema} destinationSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionMoveMyNameActionMovePost(name: string, destinationSchema: DestinationSchema, options?: any): AxiosPromise<CharacterMovementResponseSchema> {
            return localVarFp.actionMoveMyNameActionMovePost(name, destinationSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).
         * @summary Action Recycling
         * @param {string} name Name of your character.
         * @param {RecyclingSchema} recyclingSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionRecyclingMyNameActionRecyclingPost(name: string, recyclingSchema: RecyclingSchema, options?: any): AxiosPromise<RecyclingResponseSchema> {
            return localVarFp.actionRecyclingMyNameActionRecyclingPost(name, recyclingSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.
         * @summary Action Task Exchange
         * @param {string} name Name of your character.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionTaskExchangeMyNameActionTaskExchangePost(name: string, options?: any): AxiosPromise<TaskRewardResponseSchema> {
            return localVarFp.actionTaskExchangeMyNameActionTaskExchangePost(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Unequip an item on your character.
         * @summary Action Unequip Item
         * @param {string} name Name of your character.
         * @param {UnequipSchema} unequipSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionUnequipItemMyNameActionUnequipPost(name: string, unequipSchema: UnequipSchema, options?: any): AxiosPromise<EquipmentResponseSchema> {
            return localVarFp.actionUnequipItemMyNameActionUnequipPost(name, unequipSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw gold from your bank.
         * @summary Action Withdraw Bank Gold
         * @param {string} name Name of your character.
         * @param {DepositWithdrawGoldSchema} depositWithdrawGoldSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(name: string, depositWithdrawGoldSchema: DepositWithdrawGoldSchema, options?: any): AxiosPromise<GoldResponseSchema> {
            return localVarFp.actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(name, depositWithdrawGoldSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Take an item from your bank and put it in the character\'s inventory.
         * @summary Action Withdraw Bank
         * @param {string} name Name of your character.
         * @param {SimpleItemSchema} simpleItemSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionWithdrawBankMyNameActionBankWithdrawPost(name: string, simpleItemSchema: SimpleItemSchema, options?: any): AxiosPromise<ActionItemBankResponseSchema> {
            return localVarFp.actionWithdrawBankMyNameActionBankWithdrawPost(name, simpleItemSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * History of the last 100 actions of all your characters.
         * @summary Get All Characters Logs
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCharactersLogsMyLogsGet(page?: number, size?: number, options?: any): AxiosPromise<DataPageLogSchema> {
            return localVarFp.getAllCharactersLogsMyLogsGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * List of your characters.
         * @summary Get My Characters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyCharactersMyCharactersGet(options?: any): AxiosPromise<MyCharactersListSchema> {
            return localVarFp.getMyCharactersMyCharactersGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MyCharactersApi - object-oriented interface
 * @export
 * @class MyCharactersApi
 * @extends {BaseAPI}
 */
export class MyCharactersApi extends BaseAPI {
    /**
     * Accepting a new task.
     * @summary Action Accept New Task
     * @param {string} name Name of your character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionAcceptNewTaskMyNameActionTaskNewPost(name: string, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionAcceptNewTaskMyNameActionTaskNewPost(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete a task.
     * @summary Action Complete Task
     * @param {string} name Name of your character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionCompleteTaskMyNameActionTaskCompletePost(name: string, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionCompleteTaskMyNameActionTaskCompletePost(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crafting an item. The character must be on a map with a workshop.
     * @summary Action Crafting
     * @param {string} name Name of your character.
     * @param {CraftingSchema} craftingSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionCraftingMyNameActionCraftingPost(name: string, craftingSchema: CraftingSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionCraftingMyNameActionCraftingPost(name, craftingSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an item from your character\'s inventory.
     * @summary Action Delete Item
     * @param {string} name Name of your character.
     * @param {SimpleItemSchema} simpleItemSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionDeleteItemMyNameActionDeletePost(name: string, simpleItemSchema: SimpleItemSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionDeleteItemMyNameActionDeletePost(name, simpleItemSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deposit golds in a bank on the character\'s map.
     * @summary Action Deposit Bank Gold
     * @param {string} name Name of your character.
     * @param {DepositWithdrawGoldSchema} depositWithdrawGoldSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionDepositBankGoldMyNameActionBankDepositGoldPost(name: string, depositWithdrawGoldSchema: DepositWithdrawGoldSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionDepositBankGoldMyNameActionBankDepositGoldPost(name, depositWithdrawGoldSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deposit an item in a bank on the character\'s map.
     * @summary Action Deposit Bank
     * @param {string} name Name of your character.
     * @param {SimpleItemSchema} simpleItemSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionDepositBankMyNameActionBankDepositPost(name: string, simpleItemSchema: SimpleItemSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionDepositBankMyNameActionBankDepositPost(name, simpleItemSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Equip an item on your character.
     * @summary Action Equip Item
     * @param {string} name Name of your character.
     * @param {EquipSchema} equipSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionEquipItemMyNameActionEquipPost(name: string, equipSchema: EquipSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionEquipItemMyNameActionEquipPost(name, equipSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a fight against a monster on the character\'s map.
     * @summary Action Fight
     * @param {string} name Name of your character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionFightMyNameActionFightPost(name: string, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionFightMyNameActionFightPost(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Harvest a resource on the character\'s map.
     * @summary Action Gathering
     * @param {string} name Name of your character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionGatheringMyNameActionGatheringPost(name: string, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionGatheringMyNameActionGatheringPost(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Buy an item at the Grand Exchange on the character\'s map.
     * @summary Action Ge Buy Item
     * @param {string} name Name of your character.
     * @param {GETransactionItemSchema} gETransactionItemSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionGeBuyItemMyNameActionGeBuyPost(name: string, gETransactionItemSchema: GETransactionItemSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionGeBuyItemMyNameActionGeBuyPost(name, gETransactionItemSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sell an item at the Grand Exchange on the character\'s map.
     * @summary Action Ge Sell Item
     * @param {string} name Name of your character.
     * @param {GETransactionItemSchema} gETransactionItemSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionGeSellItemMyNameActionGeSellPost(name: string, gETransactionItemSchema: GETransactionItemSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionGeSellItemMyNameActionGeSellPost(name, gETransactionItemSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Moves a character on the map using the map\'s X and Y position.
     * @summary Action Move
     * @param {string} name Name of your character.
     * @param {DestinationSchema} destinationSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionMoveMyNameActionMovePost(name: string, destinationSchema: DestinationSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionMoveMyNameActionMovePost(name, destinationSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recyling an item. The character must be on a map with a workshop (only for equipments and weapons).
     * @summary Action Recycling
     * @param {string} name Name of your character.
     * @param {RecyclingSchema} recyclingSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionRecyclingMyNameActionRecyclingPost(name: string, recyclingSchema: RecyclingSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionRecyclingMyNameActionRecyclingPost(name, recyclingSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange 3 tasks coins for a random reward. Rewards are exclusive resources for crafting  items.
     * @summary Action Task Exchange
     * @param {string} name Name of your character.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionTaskExchangeMyNameActionTaskExchangePost(name: string, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionTaskExchangeMyNameActionTaskExchangePost(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unequip an item on your character.
     * @summary Action Unequip Item
     * @param {string} name Name of your character.
     * @param {UnequipSchema} unequipSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionUnequipItemMyNameActionUnequipPost(name: string, unequipSchema: UnequipSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionUnequipItemMyNameActionUnequipPost(name, unequipSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdraw gold from your bank.
     * @summary Action Withdraw Bank Gold
     * @param {string} name Name of your character.
     * @param {DepositWithdrawGoldSchema} depositWithdrawGoldSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(name: string, depositWithdrawGoldSchema: DepositWithdrawGoldSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(name, depositWithdrawGoldSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Take an item from your bank and put it in the character\'s inventory.
     * @summary Action Withdraw Bank
     * @param {string} name Name of your character.
     * @param {SimpleItemSchema} simpleItemSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public actionWithdrawBankMyNameActionBankWithdrawPost(name: string, simpleItemSchema: SimpleItemSchema, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).actionWithdrawBankMyNameActionBankWithdrawPost(name, simpleItemSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * History of the last 100 actions of all your characters.
     * @summary Get All Characters Logs
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public getAllCharactersLogsMyLogsGet(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).getAllCharactersLogsMyLogsGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of your characters.
     * @summary Get My Characters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MyCharactersApi
     */
    public getMyCharactersMyCharactersGet(options?: RawAxiosRequestConfig) {
        return MyCharactersApiFp(this.configuration).getMyCharactersMyCharactersGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch resources details.
         * @summary Get All Resources
         * @param {number} [minLevel] Skill minimum level.
         * @param {number} [maxLevel] Skill maximum level.
         * @param {GetAllResourcesResourcesGetSkillEnum} [skill] The code of the skill.
         * @param {string} [drop] Item code of the drop.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllResourcesResourcesGet: async (minLevel?: number, maxLevel?: number, skill?: GetAllResourcesResourcesGetSkillEnum, drop?: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minLevel !== undefined) {
                localVarQueryParameter['min_level'] = minLevel;
            }

            if (maxLevel !== undefined) {
                localVarQueryParameter['max_level'] = maxLevel;
            }

            if (skill !== undefined) {
                localVarQueryParameter['skill'] = skill;
            }

            if (drop !== undefined) {
                localVarQueryParameter['drop'] = drop;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details of a resource.
         * @summary Get Resource
         * @param {string} code The code of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceResourcesCodeGet: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getResourceResourcesCodeGet', 'code', code)
            const localVarPath = `/resources/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch resources details.
         * @summary Get All Resources
         * @param {number} [minLevel] Skill minimum level.
         * @param {number} [maxLevel] Skill maximum level.
         * @param {GetAllResourcesResourcesGetSkillEnum} [skill] The code of the skill.
         * @param {string} [drop] Item code of the drop.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllResourcesResourcesGet(minLevel?: number, maxLevel?: number, skill?: GetAllResourcesResourcesGetSkillEnum, drop?: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataPageResourceSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllResourcesResourcesGet(minLevel, maxLevel, skill, drop, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getAllResourcesResourcesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details of a resource.
         * @summary Get Resource
         * @param {string} code The code of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceResourcesCodeGet(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceResourcesCodeGet(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getResourceResourcesCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * Fetch resources details.
         * @summary Get All Resources
         * @param {number} [minLevel] Skill minimum level.
         * @param {number} [maxLevel] Skill maximum level.
         * @param {GetAllResourcesResourcesGetSkillEnum} [skill] The code of the skill.
         * @param {string} [drop] Item code of the drop.
         * @param {number} [page] Page number
         * @param {number} [size] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllResourcesResourcesGet(minLevel?: number, maxLevel?: number, skill?: GetAllResourcesResourcesGetSkillEnum, drop?: string, page?: number, size?: number, options?: any): AxiosPromise<DataPageResourceSchema> {
            return localVarFp.getAllResourcesResourcesGet(minLevel, maxLevel, skill, drop, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details of a resource.
         * @summary Get Resource
         * @param {string} code The code of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceResourcesCodeGet(code: string, options?: any): AxiosPromise<ResourceResponseSchema> {
            return localVarFp.getResourceResourcesCodeGet(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * Fetch resources details.
     * @summary Get All Resources
     * @param {number} [minLevel] Skill minimum level.
     * @param {number} [maxLevel] Skill maximum level.
     * @param {GetAllResourcesResourcesGetSkillEnum} [skill] The code of the skill.
     * @param {string} [drop] Item code of the drop.
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getAllResourcesResourcesGet(minLevel?: number, maxLevel?: number, skill?: GetAllResourcesResourcesGetSkillEnum, drop?: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getAllResourcesResourcesGet(minLevel, maxLevel, skill, drop, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details of a resource.
     * @summary Get Resource
     * @param {string} code The code of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getResourceResourcesCodeGet(code: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getResourceResourcesCodeGet(code, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAllResourcesResourcesGetSkillEnum = {
    Mining: 'mining',
    Woodcutting: 'woodcutting',
    Fishing: 'fishing'
} as const;
export type GetAllResourcesResourcesGetSkillEnum = typeof GetAllResourcesResourcesGetSkillEnum[keyof typeof GetAllResourcesResourcesGetSkillEnum];


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use your account as HTTPBasic Auth to generate your token to use the API. You can also generate your token directly on the website.
         * @summary Generate Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTokenTokenPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBasic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Use your account as HTTPBasic Auth to generate your token to use the API. You can also generate your token directly on the website.
         * @summary Generate Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateTokenTokenPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateTokenTokenPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokenApi.generateTokenTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenApiFp(configuration)
    return {
        /**
         * Use your account as HTTPBasic Auth to generate your token to use the API. You can also generate your token directly on the website.
         * @summary Generate Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTokenTokenPost(options?: any): AxiosPromise<TokenResponseSchema> {
            return localVarFp.generateTokenTokenPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Use your account as HTTPBasic Auth to generate your token to use the API. You can also generate your token directly on the website.
     * @summary Generate Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public generateTokenTokenPost(options?: RawAxiosRequestConfig) {
        return TokenApiFp(this.configuration).generateTokenTokenPost(options).then((request) => request(this.axios, this.basePath));
    }
}



